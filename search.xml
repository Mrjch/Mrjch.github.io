<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>综合后仿真，sdf文件反标时出现的问题</title>
      <link href="/2019/09/20/%E7%BB%BC%E5%90%88%E5%90%8E%E4%BB%BF%E7%9C%9F%EF%BC%8Csdf%E6%96%87%E4%BB%B6%E5%8F%8D%E6%A0%87%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/20/%E7%BB%BC%E5%90%88%E5%90%8E%E4%BB%BF%E7%9C%9F%EF%BC%8Csdf%E6%96%87%E4%BB%B6%E5%8F%8D%E6%A0%87%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>##如何得到SDF文件？<br>在Design Compiler综合后用write_sdf命令导出。</p><p>##Verilog Testbench的SDF反标<br>如果testbench是用verilog写的，则在initial之后加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sdf_annotate(&quot;xxx.sdf&quot;,top_module_name);</span><br></pre></td></tr></table></figure><p>top_module_name表示sdf所要标注的模块名称，如果有多层结构，中间要用”.”隔开，如top_module_name.sub_module_name。(模块名称及例化时，后面的名字)</p><p>##遇到问题</p><img src="/2019/09/20/综合后仿真，sdf文件反标时出现的问题/1.png" title="node.js"><p>原因是我把反标命令的里文件搞成了.v文件。反标命令里的文件要注意是.sdf文件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>testbench中阻塞赋值和非阻塞赋值的问题</title>
      <link href="/2019/09/03/testbench%E4%B8%AD%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/03/testbench%E4%B8%AD%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今天写仿真文件时遇到了阻塞赋值和非阻塞赋值会出现不同的仿真结果，原因未知，占坑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Genus入门</title>
      <link href="/2019/08/12/Genus%E5%85%A5%E9%97%A8/"/>
      <url>/2019/08/12/Genus%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>由于项目需要使用Genus综合，特开此篇博客记录学习点滴</p><h1 id="一、run-tcl命令解释"><a href="#一、run-tcl命令解释" class="headerlink" title="一、run.tcl命令解释"></a>一、run.tcl命令解释</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::legacy::set_attribute common_ui false /</span><br></pre></td></tr></table></figure><p>如果使用Common UI调用Genus，则使用以下属性在Legacy UI中运行Genus</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set DESIGN dtmf_recvr_core</span><br></pre></td></tr></table></figure><p>把变量名指定为顶层设计名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set SYN_EFF medium</span><br><span class="line">set MAP_EFF medium</span><br><span class="line">set OPT_EFF medium</span><br></pre></td></tr></table></figure><p>三个变量表示综合的不同阶段的工作量（synthesize to generic,to gates,optimization）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set DATE [clock format [clock seconds] -format &quot;%b%d-%T&quot;]</span><br><span class="line">set _OUTPUTS_PATH outputs_$&#123;DATE&#125;</span><br><span class="line">set _REPORTS_PATH reports_$&#123;DATE&#125;</span><br><span class="line">set _LOG_PATH logs_$&#123;DATE&#125;</span><br></pre></td></tr></table></figure><p>以上几个命令用来建立存放reports,dbs和logfiles的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_attribute init_lib_search_path &#123;. ../LIB&#125; / </span><br><span class="line">set_attribute script_search_path &#123;. ../scripts&#125; / </span><br><span class="line">set_attribute init_hdl_search_path &#123;. ../RTL&#125; /</span><br></pre></td></tr></table></figure><p>上面三个属性用来指定cell libraries，script，RTL搜索路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if &#123;![file exists $&#123;_LOG_PATH&#125;]&#125; &#123;</span><br><span class="line">file mkdir $&#123;_LOG_PATH&#125;</span><br><span class="line">puts &quot;Creating directory $&#123;_LOG_PATH&#125;&quot; </span><br><span class="line">&#125;</span><br><span class="line">if &#123;![file exists $&#123;_OUTPUTS_PATH&#125;]&#125; &#123;</span><br><span class="line">file mkdir $&#123;_OUTPUTS_PATH&#125;</span><br><span class="line">puts &quot;Creating directory $&#123;_OUTPUTS_PATH&#125;&quot; </span><br><span class="line">&#125; </span><br><span class="line">if &#123;![file exists $&#123;_REPORTS_PATH&#125;]&#125; &#123; </span><br><span class="line">file mkdir $&#123;_REPORTS_PATH&#125;  </span><br><span class="line">puts &quot;Creating directory $&#123;_REPORTS_PATH&#125;&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建必要的文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_attribute syn_generic_effort $SYN_EFF /</span><br><span class="line">set_attribute syn_map_effort $MAP_EFF /</span><br><span class="line">set_attribute syn_opt_effort $OPT_EFF /</span><br></pre></td></tr></table></figure><p>设置综合每一阶段的综合工作量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_attribute max_cpus_per_server 8 /</span><br></pre></td></tr></table></figure><p>综合过程中超线程数目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_attribute information_level 9 /</span><br></pre></td></tr></table></figure><p>以上属性指定降多少信息写入日志文件，若出于调试目的以及向Cadence提供测试用例时，将值设置为9，若限制详细信息，则值为7或5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_attribute library &#123; ../LIB/slow.lib ../LIB/pll.lib  ../LIB/CDK_S128x16.lib  ../LIB/CDK_S256x16.lib  ../LIB/CDK_R512x16.lib&#125; /</span><br></pre></td></tr></table></figure><p>以上属性指定设计所需要的各种库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_attribute lef_library &#123; ../LEF/gsclib045_tech.lef ../LEF/gsclib045_macro.lef ../L EF/pll.lef    ../LEF/CDK_S128x16.lef  ../LEF/CDK_S256x16.lef  ../LEF/CDK _R512x16.lef   &#125; /</span><br></pre></td></tr></table></figure><p>指定设计需要的lef库（实体模型）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_attribute cap_table_file &lt;file&gt; /</span><br></pre></td></tr></table></figure><p>指定实际需要的cap_table文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_attribute hdl_unconnected_input_port_value 0 | 1 | x | none /</span><br><span class="line">set_attribute hdl_undriven_output_port_value   0 | 1 | x | none /</span><br><span class="line">set_attribute hdl_undriven_signal_value        0 | 1 | x | none /</span><br></pre></td></tr></table></figure><p>指定设计里信号线的初始状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read_hdl &quot; *.v&quot;</span><br><span class="line">elaborate $DESIGN</span><br><span class="line">time_info Elaboration </span><br><span class="line">check_design -unresolved</span><br></pre></td></tr></table></figure><p>以上命令功能分别为：加载RLT设计到Genus内存。<br>elaborate顶层设计<br>报告此阶段使用的运行时间和内存<br>优先检查未解决的实例（以确保综合的准确性）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read_sdc ../Constraints/dtmf_recvr_core_gate.sdc</span><br></pre></td></tr></table></figure><p>上面命令读取约束文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report timing -lint</span><br></pre></td></tr></table></figure><p>以上命令生成lint报告，此报告简略输出设计中可能存在的时序问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if &#123;[llength [all::all_seqs]] &gt; 0&#125; &#123; </span><br><span class="line"> define_cost_group -name I2C -design $DESIGN</span><br><span class="line"> define_cost_group -name C2O -design $DESIGN</span><br><span class="line"> define_cost_group -name C2C -design $DESIGN</span><br><span class="line"> path_group -from [all::all_seqs] -to [all::all_seqs] -group C2C -name C2C</span><br><span class="line"> path_group -from [all::all_seqs] -to [all::all_outs] -group C2O -name C2O</span><br><span class="line"> path_group -from [all::all_inps]  -to [all::all_seqs] -group I2C -name I2C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define_cost_group -name I2O -design $DESIGN</span><br><span class="line">path_group -from [all::all_inps]  -to [all::all_outs] -group I2O -name I2O</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syn_generic</span><br><span class="line">syn_map</span><br></pre></td></tr></table></figure><p>以上命令执行通用综合和全局映射</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo安装笔记</title>
      <link href="/2019/08/08/Hexo%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/08/08/Hexo%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo安装笔记"><a href="#Hexo安装笔记" class="headerlink" title="Hexo安装笔记"></a>Hexo安装笔记</h1><h2 id="一、下载node-js"><a href="#一、下载node-js" class="headerlink" title="一、下载node.js"></a>一、下载node.js</h2><p>由于Hexo基于node.js编写的，所以在安装Hexo之前需要安装node.js<br>百度搜索node.js,进入官网，根据操作系统下载相应的版本，这里使用的操作系统为windows，并选择下载左边的长期支持版本。</p><img src="/2019/08/08/Hexo安装笔记/1.png" title="node.js"><p>一顿傻瓜式安装后，打开windows的命令行程序，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>如果出现相应的版本提示，则表示安装成功。</p><h2 id="二、安装Hexo"><a href="#二、安装Hexo" class="headerlink" title="二、安装Hexo"></a>二、安装Hexo</h2><p>在命令行中敲入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>等待安装完成后，可以正式开始hexo的使用了</p><h2 id="三、Hexo使用"><a href="#三、Hexo使用" class="headerlink" title="三、Hexo使用"></a>三、Hexo使用</h2><p>再使用Hexo之前，可以创建一个存放博客文件的文件blog，然后cd到这个文件夹下。<br>首先初始化hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>初始化完成后可以看到在blog文件夹下有一下文件和目录：</p><ul><li>node_modules/ 用来存放依赖包</li><li>public/ 用来存放生成的页面相关文件</li><li>scaffolds/ 命令生成文章等的模版</li><li>source/ 用来存放创建的博客文章</li><li>themes/ 用来存放博客的主题</li><li>_config.yml 整个博客的配置文件</li><li>db.json 生成文件</li><li>package.json 项目所需模块项目的配置信息</li><li>package-lock.json 存放锁定的版本号，确保安装依赖是保持一致<br>然后输入命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></li></ul><p>就可启动hexo<br>在浏览器键入localhost:4000 便可以看到博客的初始样貌了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的第一篇博客文章&quot;</span><br></pre></td></tr></table></figure><img src="/2019/08/08/Hexo安装笔记/2.png" title="node.js"><p>下一步便可以将hexo博客推动到远端服务器</p><h2 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h2><p>几个常用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
